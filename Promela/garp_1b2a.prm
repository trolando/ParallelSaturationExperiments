/* * The model of Generic Attribute Registration Protocol * as specified in IEEE Std 802.1D 2004. * * This file must be preprocessed by python-mako template engine. *  * Revision:   25 * Latest fix: FIX9 (extracted GIP process from GID) * Date:       Apr 2010 *  * Igor Konnov, 2009-2010 * * General abstractions: *  - The only application, the only attribute and the only attribute value *    are considered. *  - Participants exchange data by asynchronous channels of size 1 *    (the spec does not say specifically about GIP communication mechanism). *  - Participants are connected in a tree. *  - Participants do not fail. However, packets may be lost. *  - IMPORTANT: all applications (and their attached GIDs) are located *    in different LANs! */#define __instances_GID_ARLA 2#define __instances_GID_A 2#define __instances_GIP2 1mtype = { Empty, JoinEmpty, JoinIn, LeaveIn, LeaveEmpty, LeaveAll,          ReqJoin, ReqLeave };/* registrar states */#define MT 0#define LV 1#define IN 2/* applicant states */#define VA 0#define AA 1#define QA 2#define LA 3#define VP 4#define AP 5#define QP 6#define VO 7#define AO 8#define QO 9#define LO 10/* global definitions (ease specifications) */chan port[4] = [1] of { mtype };chan gip_in[2] = [1] of { mtype };chan gip_out[2] = [1] of { mtype };byte rs[4]; /* registrar states */    /**     * Node of bridge consisting of GARP Information Declaration entities.     * According to p. 80 of spec it contains Application and Registrar.     * Also it contains LeaveAll component according to p. 88 of spec.     */    proctype GID_ARLA(byte id, port_in_id, port_out_id, gip_id) {        byte as;        byte leave_timer;            mtype m;        /* initialize states */        d_step {            as = VO;            rs[id] = MT;            leave_timer = 0;            m = Empty;        }        /* main loop */        do            /* built-in application indicates ReqJoin */            :: (as == LA || as >= VO && as <= LO) ->                /* ReqJoin is issued either by other GID, or by application */                /* applicant: ReqJoin */progress_GID_ARLA_application_join:                                printf("MSC: ReqJoin!\n");                d_step {                    if                        :: as == LA -> as = VA;                        :: as == VO -> as = VP;                        :: as == AO -> as = AP;                        :: as == QO -> as = QP;                        :: as == LO -> as = VP;                    fi;                }            :: (as == LA || as >= VO && as <= LO)                    && gip_out[gip_id]?[ReqJoin] ->                /* IndJoin is indicated by GIP */                /* GIP: IndJoin */progress_GID_ARLA_join:                gip_out[gip_id]?ReqJoin;                d_step {                    if                        :: as == LA -> as = VA;                        :: as == VO -> as = VP;                        :: as == AO -> as = AP;                        :: as == QO -> as = QP;                        :: as == LO -> as = VP;                    fi;                }            :: (as >= VA && as <= QA || as >= VP && as <= QP) ->                /* ReqJoin is issued either by other GID, or by application */                /* applicant: ReqLeave */progress_GID_ARLA_application_leave:                                d_step {                    printf("MSC: ReqLeave!\n");                    if                        :: as >= VA && as <= QA -> as = LA;                        :: as == VP -> as = VO;                        :: as == AP -> as = AO;                        :: as == QP -> as = QO;                    fi;                }                            :: (as >= VA && as <= QA || as >= VP && as <= QP)                    && gip_out[gip_id]?[ReqLeave] ->                /* IndLeave is issued either by other GID, or by application */                /* GIP: IndLeave */progress_GID_ARLA_leave:                                gip_out[gip_id]?ReqLeave;                d_step {                    if                        :: as >= VA && as <= QA -> as = LA;                        :: as == VP -> as = VO;                        :: as == AP -> as = AO;                        :: as == QP -> as = QO;                    fi;                }            :: (port[port_in_id]?[JoinIn] || port[port_in_id]?[JoinEmpty]) ->                /* registrar: rJoinIn, rJoinEmpty */                /* receive JoinIn or JoinEmpty */                port[port_in_id]?m;                d_step {                /* applicant: rJoinIn, rJoinEmpty */                    if                        :: m == JoinIn ->                            if                                 :: as == VA -> as = AA;                                :: as == AA -> as = QA;                                :: as == QA -> as = QA;                                :: as == LA -> as = LA;                                :: as == VP -> as = AP;                                :: as == AP -> as = QP;                                :: as == QP -> as = QP;                                :: as == VO -> as = AO;                                :: as == AO -> as = QO;                                :: as == QO -> as = QO;                                :: as == LO -> as = AO;                            fi;                        :: m == JoinEmpty ->                            if                                 :: as == VA -> as = VA;                                :: as == AA -> as = VA;                                :: as == QA -> as = VA;                                :: as == LA -> as = VO;                                :: as == VP -> as = AP;                                :: as == AP -> as = VP;                                :: as == QP -> as = VP;                                :: as == VO -> as = VO;                                :: as == AO -> as = VO;                                :: as == QO -> as = VO;                                :: as == LO -> as = VO;                            fi;                    fi;                }                /* registrar: continuing... */                if                    :: rs[id] == IN /* IN */;                    :: rs[id] == LV ->                        d_step {                            leave_timer = 0;   /* Stop leave_timer */                            rs[id] = IN;       /* IN */                        }                        gip_in[gip_id]!ReqJoin;    /* ReqJoin */        /* FIX8: application joins on IndJoin */                    :: rs[id] == MT ->                        rs[id] = IN;          /* IN */                        gip_in[gip_id]!ReqJoin;    /* ReqJoin */        /* FIX8: application joins on IndJoin */               fi;            :: port[port_in_id]?Empty ->                d_step {                /* registrar: rEmpty */                /* registrar state is not changed */                /* applicant: rEmpty */                    if                        :: as == VA || as == AA || as == QA ->                            as = VA;                        :: as == LA; /* state is preserved */                        :: as == VP || as == AP || as == QP ->                            as = VP;                        :: as == VO || as == AO || as == QO || as == LO ->                            as = VO;                    fi;                }            :: port[port_in_id]?[LeaveIn] || port[port_in_id]?[LeaveEmpty] ->                port[port_in_id]?m;                d_step {                /* registrar: rLeaveIn, rLeaveEmpty */                    if                        :: rs[id] == IN ->                            leave_timer = 1; /* start leave_timer */                            rs[id] = LV;     /* LV */                        :: else              /* do nothing */                    fi;                /* applicant: rLeaveIn, rLeaveEmpty */                    if                        :: m == LeaveIn ->                            if                                :: as == AA -> as = VA;                                :: as == QA -> as = VP;                                :: as == AP -> as = VP;                                :: as == QP -> as = VP;                                :: as == VO -> as = LO;                                :: as == AO -> as = LO;                                :: as == QO -> as = LO;                                :: as == LO -> as = LO;                                :: else;                            fi;                        :: m == LeaveEmpty ->                            if                                :: as == VA -> as = VP;                                :: as == AA -> as = VP;                                :: as == QA -> as = VP;                                :: as == LA -> as = VO;                                :: as == AP -> as = VP;                                :: as == QP -> as = VP;                                :: as == VO -> as = LO;                                :: as == AO -> as = LO;                                :: as == QO -> as = LO;                                :: as == LO -> as = VO;                                :: else;                            fi;                    fi;                } /* end of d_step */            :: leave_timer && rs[id] == LV ->                /* registrar: leave_timer! */                d_step {                    printf("MSC: leavetimer!\n");                    leave_timer = 0; /* FIX6: Stop leave_timer (it is expired!) */                    rs[id] = MT;                }                gip_in[gip_id]!ReqLeave; /* ReqLeave */            ::  /* leavealltimer! */ nfull(port[port_out_id]) ->progress_GID_ARLA_leavealltimer:                d_step {                    printf("MSC: leavealltimer!\n");                    /* sLeaveAll event */                    /* registrar: LeaveAll */                    if                        :: rs[id] == IN ->                                leave_timer = 1; /* start leave_timer */                                rs[id] = LV;     /* LV */                        :: else                  /* do nothing */                    fi;                                /* applicant: LeaveAll */                    if                        :: as == VA -> as = VP;                        :: as == AA -> as = VP;                        :: as == QA -> as = VP;                        :: as == LA -> as = VO;                        :: as == VP -> as = VP;                        :: as == AP -> as = VP;                        :: as == QP -> as = VP;                        :: as == VO -> as = LO;                        :: as == AO -> as = LO;                        :: as == QO -> as = LO;                        :: as == LO -> as = VO;                    fi;                } /* end of d_step */                /* FIX4: finally send LeaveAll to port */                /*                   We don't have to send LeaveAll by GIP as all the bridge                   participants are agreed to Leave.                 */                port[port_out_id]!LeaveAll;            /* FIX4: reaction on LeaveAll */            :: port[port_in_id]?[LeaveAll] ->                /* rLeaveAll */                port[port_in_id]?LeaveAll;                d_step {                /* registrar: LeaveAll */                    if                        :: rs[id] == IN ->                                leave_timer = 1; /* start leave_timer */                                rs[id] = LV;     /* LV */                        :: else                  /* do nothing */                    fi;                                /* applicant: LeaveAll */                    if                        :: as == VA -> as = VP;                        :: as == AA -> as = VP;                        :: as == QA -> as = VP;                        :: as == LA -> as = VO;                        :: as == VP -> as = VP;                        :: as == AP -> as = VP;                        :: as == QP -> as = VP;                        :: as == VO -> as = LO;                        :: as == AO -> as = LO;                        :: as == QO -> as = LO;                        :: as == LO -> as = VO;                    fi;                } /* end of d_step */            :: (as == VA || as == AA || as == VP || as == AP)                    && /* FIX2 */ nfull(port[port_out_id]) ->                /* applicant: transmitPDU! */                printf("MSC: transmitPDU!\n");                if                    :: rs[id] == IN ->                        port[port_out_id]!JoinIn;                    :: else -> port[port_out_id]!JoinEmpty;                fi;                d_step {                    if                        :: as == VA -> as = AA;                        :: as == AA -> as = QA;                        :: as == VP -> as = AA;                        :: as == AP -> as = QA;                    fi;                }            :: as == LA && /* FIX2 */ nfull(port[port_out_id]) ->                printf("MSC: transmitPDU!\n");                /* AMBIGUITY #2 */                /* according to combined applicant/registrar table */                /*                if                    :: rs[id] == IN -> rs[id] = LV;                    :: else;                fi;                */                /* applicant: transmitPDU! */                as = VO;                port[port_out_id]!LeaveEmpty;            :: as == LO && /* FIX2 */ nfull(port[port_out_id]) ->                /* applicant: transmitPDU! */                d_step {                    printf("MSC: transmitPDU!\n");                    as = VO;                }                port[port_out_id]!Empty; /* FIX3 */        od;    }    /**     * Node of bridge consisting of GARP Information Declaration entities.     * According to p. 80 of spec it contains Application and Registrar.     * Also it contains LeaveAll component according to p. 88 of spec.     */    proctype GID_A(byte id, port_in_id, port_out_id) {        byte as;            mtype m;        /* initialize states */        d_step {            as = VO;            m = Empty;        }        /* main loop */        do            /* built-in application indicates ReqJoin */            :: (as == LA || as >= VO && as <= LO) ->                /* ReqJoin is issued either by other GID, or by application */                /* applicant: ReqJoin */progress_GID_A_application_join:                                printf("MSC: ReqJoin!\n");                d_step {                    if                        :: as == LA -> as = VA;                        :: as == VO -> as = VP;                        :: as == AO -> as = AP;                        :: as == QO -> as = QP;                        :: as == LO -> as = VP;                    fi;                }            :: (as >= VA && as <= QA || as >= VP && as <= QP) ->                /* ReqJoin is issued either by other GID, or by application */                /* applicant: ReqLeave */progress_GID_A_application_leave:                                d_step {                    printf("MSC: ReqLeave!\n");                    if                        :: as >= VA && as <= QA -> as = LA;                        :: as == VP -> as = VO;                        :: as == AP -> as = AO;                        :: as == QP -> as = QO;                    fi;                }                            :: (port[port_in_id]?[JoinIn] || port[port_in_id]?[JoinEmpty]) ->                /* registrar: rJoinIn, rJoinEmpty */                /* receive JoinIn or JoinEmpty */                port[port_in_id]?m;                d_step {                /* applicant: rJoinIn, rJoinEmpty */                    if                        :: m == JoinIn ->                            if                                 :: as == VA -> as = AA;                                :: as == AA -> as = QA;                                :: as == QA -> as = QA;                                :: as == LA -> as = LA;                                :: as == VP -> as = AP;                                :: as == AP -> as = QP;                                :: as == QP -> as = QP;                                :: as == VO -> as = AO;                                :: as == AO -> as = QO;                                :: as == QO -> as = QO;                                :: as == LO -> as = AO;                            fi;                        :: m == JoinEmpty ->                            if                                 :: as == VA -> as = VA;                                :: as == AA -> as = VA;                                :: as == QA -> as = VA;                                :: as == LA -> as = VO;                                :: as == VP -> as = AP;                                :: as == AP -> as = VP;                                :: as == QP -> as = VP;                                :: as == VO -> as = VO;                                :: as == AO -> as = VO;                                :: as == QO -> as = VO;                                :: as == LO -> as = VO;                            fi;                    fi;                }            :: port[port_in_id]?Empty ->                d_step {                /* registrar: rEmpty */                /* registrar state is not changed */                /* applicant: rEmpty */                    if                        :: as == VA || as == AA || as == QA ->                            as = VA;                        :: as == LA; /* state is preserved */                        :: as == VP || as == AP || as == QP ->                            as = VP;                        :: as == VO || as == AO || as == QO || as == LO ->                            as = VO;                    fi;                }            :: port[port_in_id]?[LeaveIn] || port[port_in_id]?[LeaveEmpty] ->                port[port_in_id]?m;                d_step {                /* applicant: rLeaveIn, rLeaveEmpty */                    if                        :: m == LeaveIn ->                            if                                :: as == AA -> as = VA;                                :: as == QA -> as = VP;                                :: as == AP -> as = VP;                                :: as == QP -> as = VP;                                :: as == VO -> as = LO;                                :: as == AO -> as = LO;                                :: as == QO -> as = LO;                                :: as == LO -> as = LO;                                :: else;                            fi;                        :: m == LeaveEmpty ->                            if                                :: as == VA -> as = VP;                                :: as == AA -> as = VP;                                :: as == QA -> as = VP;                                :: as == LA -> as = VO;                                :: as == AP -> as = VP;                                :: as == QP -> as = VP;                                :: as == VO -> as = LO;                                :: as == AO -> as = LO;                                :: as == QO -> as = LO;                                :: as == LO -> as = VO;                                :: else;                            fi;                    fi;                } /* end of d_step */            /* FIX4: reaction on LeaveAll */            :: port[port_in_id]?[LeaveAll] ->                /* rLeaveAll */                port[port_in_id]?LeaveAll;                d_step {                                /* applicant: LeaveAll */                    if                        :: as == VA -> as = VP;                        :: as == AA -> as = VP;                        :: as == QA -> as = VP;                        :: as == LA -> as = VO;                        :: as == VP -> as = VP;                        :: as == AP -> as = VP;                        :: as == QP -> as = VP;                        :: as == VO -> as = LO;                        :: as == AO -> as = LO;                        :: as == QO -> as = LO;                        :: as == LO -> as = VO;                    fi;                } /* end of d_step */            :: (as == VA || as == AA || as == VP || as == AP)                    && /* FIX2 */ nfull(port[port_out_id]) ->                /* applicant: transmitPDU! */                printf("MSC: transmitPDU!\n");                port[port_out_id]!JoinIn; /* no registrar component */                d_step {                    if                        :: as == VA -> as = AA;                        :: as == AA -> as = QA;                        :: as == VP -> as = AA;                        :: as == AP -> as = QA;                    fi;                }            :: as == LA && /* FIX2 */ nfull(port[port_out_id]) ->                printf("MSC: transmitPDU!\n");                /* applicant: transmitPDU! */                as = VO;                port[port_out_id]!LeaveEmpty;            :: as == LO && /* FIX2 */ nfull(port[port_out_id]) ->                /* applicant: transmitPDU! */                d_step {                    printf("MSC: transmitPDU!\n");                    as = VO;                }                port[port_out_id]!Empty; /* FIX3 */        od;    }    /**     * GIP process parameterized by a number of connected GIDs.     * Its behaviour is described in 12.2.3.     *     * This process uses three global arrays:     *  - chan gip_in[N] = [1] of { mtype }, the array of requests;     *  - chan gip_out[N] = [1] of { mtype }, the array of indications;     *  - byte rs[N], the array of registrar states.     */     proctype GIP2(byte gid0_id, gid1_id) {        do            ::gip_in[gid0_id]?ReqJoin ->                /* propagate to other gids */                gip_out[gid1_id]!ReqJoin;            ::gip_in[gid0_id]?ReqLeave ->                /* propagate iff there is no registration on other ports */                if                    ::rs[gid1_id] == MT ->                        gip_out[gid1_id]!ReqLeave;                    ::else                fi            ::gip_in[gid1_id]?ReqJoin ->                /* propagate to other gids */                gip_out[gid0_id]!ReqJoin;            ::gip_in[gid1_id]?ReqLeave ->                /* propagate iff there is no registration on other ports */                if                    ::rs[gid0_id] == MT ->                        gip_out[gid0_id]!ReqLeave;                    ::else                fi        od    }init {    run GID_ARLA(0, 0, 1, 0); /* GID_ARLA1 pid: 1 */    run GID_ARLA(1, 2, 3, 1); /* GID_ARLA2 pid: 2 */    run GID_A(2, 1, 0); /* GID_A1 pid: 3 */    run GID_A(3, 3, 2); /* GID_A2 pid: 4 */    run GIP2(0, 1); /* GIP2 pid: 5 */}